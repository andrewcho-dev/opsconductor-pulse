# Prompt 007 — ALB + Listener Rules + Target Groups

## Your Task

Create `infra/terraform/alb.tf`.

The ALB routes HTTP/HTTPS traffic to the correct ECS services by path prefix:

| Path prefix | Target service | Notes |
|-------------|----------------|-------|
| `/api/*` | `ui_iot` port 8080 | REST API |
| `/ingest/*` | `ui_iot` port 8080 | HTTP ingest path |
| `/provision/*` | `provision_api` port 8080 | Device provisioning |
| `/auth/*` | `keycloak` port 8080 | Keycloak OIDC |
| `/webhook/*` | `webhook_receiver` port 8080 | Webhook receiver |
| `/*` (default) | `ui_iot` port 8080 | SPA catch-all |

```hcl
resource "aws_lb" "main" {
  name               = "${local.name_prefix}-alb"
  internal           = false
  load_balancer_type = "application"
  security_groups    = [aws_security_group.alb.id]
  subnets            = aws_subnet.public[*].id

  tags = { Name = "${local.name_prefix}-alb" }
}

# Target groups — one per HTTP-facing service
resource "aws_lb_target_group" "ui_iot" {
  name        = "${local.name_prefix}-ui-iot"
  port        = 8080
  protocol    = "HTTP"
  vpc_id      = aws_vpc.main.id
  target_type = "ip"  # Required for Fargate

  health_check {
    path                = "/api/v2/health"
    healthy_threshold   = 2
    unhealthy_threshold = 3
    interval            = 30
    timeout             = 10
  }
}

resource "aws_lb_target_group" "provision_api" {
  name        = "${local.name_prefix}-provision-api"
  port        = 8080
  protocol    = "HTTP"
  vpc_id      = aws_vpc.main.id
  target_type = "ip"

  health_check {
    path = "/health"
  }
}

resource "aws_lb_target_group" "keycloak" {
  name        = "${local.name_prefix}-keycloak"
  port        = 8080
  protocol    = "HTTP"
  vpc_id      = aws_vpc.main.id
  target_type = "ip"

  health_check {
    path = "/health/ready"
  }
}

resource "aws_lb_target_group" "webhook_receiver" {
  name        = "${local.name_prefix}-webhook"
  port        = 8080
  protocol    = "HTTP"
  vpc_id      = aws_vpc.main.id
  target_type = "ip"

  health_check {
    path = "/health"
  }
}

# HTTP listener (redirect to HTTPS if cert available; else forward for dev)
resource "aws_lb_listener" "http" {
  load_balancer_arn = aws_lb.main.arn
  port              = 80
  protocol          = "HTTP"

  # For dev (no cert): forward directly
  # For prod: change to redirect to HTTPS
  default_action {
    type             = "forward"
    target_group_arn = aws_lb_target_group.ui_iot.arn
  }
}

# Listener rules
resource "aws_lb_listener_rule" "provision" {
  listener_arn = aws_lb_listener.http.arn
  priority     = 10

  action {
    type             = "forward"
    target_group_arn = aws_lb_target_group.provision_api.arn
  }

  condition {
    path_pattern { values = ["/provision/*"] }
  }
}

resource "aws_lb_listener_rule" "keycloak" {
  listener_arn = aws_lb_listener.http.arn
  priority     = 20

  action {
    type             = "forward"
    target_group_arn = aws_lb_target_group.keycloak.arn
  }

  condition {
    path_pattern { values = ["/auth/*"] }
  }
}

resource "aws_lb_listener_rule" "webhook" {
  listener_arn = aws_lb_listener.http.arn
  priority     = 30

  action {
    type             = "forward"
    target_group_arn = aws_lb_target_group.webhook_receiver.arn
  }

  condition {
    path_pattern { values = ["/webhook/*"] }
  }
}

output "alb_dns_name" {
  description = "ALB DNS name — point your domain CNAME here"
  value       = aws_lb.main.dns_name
}
```

## Important: `aws_lb_listener` reference in `ecs.tf`

`ecs.tf` (prompt 006) references `aws_lb_listener.https` in `depends_on`. Since we are using HTTP for dev (no cert), change that reference to `aws_lb_listener.http` in `ecs.tf`.

## Acceptance Criteria

- [ ] `alb.tf` exists with ALB, 4 target groups, HTTP listener, 3 listener rules
- [ ] Health check paths match actual service health endpoints
- [ ] `target_type = "ip"` on all target groups (required for Fargate)
- [ ] `terraform validate` passes
- [ ] Output `alb_dns_name` defined
