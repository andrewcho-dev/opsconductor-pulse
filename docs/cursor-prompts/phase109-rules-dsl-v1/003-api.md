# Phase 109 — API: conditions + match_mode in Alert Rule CRUD

## File to modify
`services/ui_iot/routes/alerts.py`

Read the file in full before making changes. Identify:
- `AlertRuleCreate` and `AlertRuleUpdate` Pydantic models
- The INSERT SQL for creating a rule
- The UPDATE SQL for updating a rule
- The SELECT SQL that returns rules to callers

---

## Step 1: Add condition model

```python
from typing import Optional, Any
from pydantic import BaseModel, Field, validator


class RuleCondition(BaseModel):
    metric_name: str = Field(..., min_length=1)
    operator: str = Field(..., pattern="^(GT|GTE|LT|LTE)$")
    threshold: float
    duration_minutes: Optional[int] = Field(default=None, ge=1)
```

---

## Step 2: Update AlertRuleCreate

Add `conditions` and `match_mode` to the existing model:

```python
class AlertRuleCreate(BaseModel):
    # ... existing fields (name, severity, etc.) ...

    # Legacy single-condition fields — keep for backwards compat
    metric_name: Optional[str] = None
    operator: Optional[str] = None
    threshold: Optional[float] = None
    duration_minutes: Optional[int] = Field(default=None, ge=1)

    # New multi-condition fields
    conditions: list[RuleCondition] = Field(default_factory=list)
    match_mode: str = Field(default="all", pattern="^(all|any)$")

    @validator("conditions", always=True)
    def validate_conditions_or_legacy(cls, conditions, values):
        has_legacy = all(
            values.get(f) is not None
            for f in ("metric_name", "operator", "threshold")
        )
        if not conditions and not has_legacy:
            raise ValueError(
                "Provide either 'conditions' array or legacy metric_name/operator/threshold"
            )
        return conditions
```

Apply the same additions to `AlertRuleUpdate` if it exists.

---

## Step 3: Update INSERT SQL

In the create endpoint handler, build the `conditions` JSON to insert:

```python
# Resolve conditions: prefer explicit conditions array,
# fall back to building one from legacy fields
if body.conditions:
    conditions_json = [c.dict() for c in body.conditions]
else:
    # Legacy path: build a single-condition array
    conditions_json = [{
        "metric_name": body.metric_name,
        "operator": body.operator,
        "threshold": body.threshold,
        "duration_minutes": body.duration_minutes,
    }]

import json
conditions_value = json.dumps(conditions_json)
```

Add `conditions` and `match_mode` to the INSERT:

```sql
INSERT INTO alert_rules
  (tenant_id, name, description, enabled, severity, rule_type,
   metric_name, operator, threshold, duration_minutes,
   conditions, match_mode,
   site_ids, group_ids, device_type, escalation_policy_id)
VALUES
  ($1, $2, $3, $4, $5, $6,
   $7, $8, $9, $10,
   $11::jsonb, $12,
   $13, $14, $15, $16)
RETURNING *
```

Pass `conditions_value` (the JSON string, cast to jsonb) and `body.match_mode`.

---

## Step 4: Update SELECT to return conditions + match_mode

If the SELECT currently returns `*`, both columns will be included automatically
after migration 078 adds `match_mode`. Confirm by checking the response shape:

```bash
curl -s "http://localhost:8000/customer/alert-rules" \
  -H "Authorization: Bearer $TOKEN" | \
  python3 -c "import sys,json; rules=json.load(sys.stdin); print(list(rules[0].keys()) if rules else 'no rules')"
```

Expected: `conditions` and `match_mode` in the key list.

---

## Step 5: Update the UPDATE SQL

In the PATCH/PUT handler for updating a rule, add `conditions` and `match_mode`
to the SET clause:

```sql
UPDATE alert_rules
SET name             = $1,
    description      = $2,
    enabled          = $3,
    severity         = $4,
    conditions       = $5::jsonb,
    match_mode       = $6,
    duration_minutes = $7,
    updated_at       = NOW()
WHERE tenant_id = $8 AND rule_id = $9
RETURNING *
```

---

## Step 6: Smoke test

```bash
# Create a two-condition AND rule
curl -s -X POST "http://localhost:8000/customer/alert-rules" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "name": "High temp AND high humidity",
    "severity": 2,
    "match_mode": "all",
    "conditions": [
      {"metric_name": "temp_c", "operator": "GT", "threshold": 40},
      {"metric_name": "humidity_pct", "operator": "GT", "threshold": 80}
    ]
  }' | python3 -m json.tool | grep -E "rule_id|match_mode|conditions"
```

Expected: `match_mode: "all"`, `conditions` array with 2 items.
