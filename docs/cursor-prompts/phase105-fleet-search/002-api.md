# Phase 105 — API: Fleet Search Parameters

## File to modify
`services/ui_iot/routes/devices.py`

## Step 1: Read the current GET /customer/devices handler

Read `services/ui_iot/routes/devices.py`. Find the function decorated with
`@router.get("/devices")` (or similar). Note the current SQL query and
return shape.

## Step 2: Add query parameters

Add these optional parameters to the handler signature:

```python
from typing import Optional
from fastapi import Query

@router.get("/devices")
async def list_devices(
    # ... existing params (e.g. pool, user) ...
    search: Optional[str] = Query(default=None, max_length=200),
    status: Optional[str] = Query(default=None),
    site_id: Optional[str] = Query(default=None),
    tag: Optional[str] = Query(default=None, description="Filter by tag value (JSONB containment)"),
    limit: int = Query(default=100, ge=1, le=1000),
    offset: int = Query(default=0, ge=0),
):
```

## Step 3: Build the filter SQL dynamically

Replace the current static WHERE clause with a dynamic builder:

```python
conditions = ["d.tenant_id = $1"]
params: list = [tenant_id]

if status:
    params.append(status)
    conditions.append(f"d.status = ${len(params)}")

if site_id:
    params.append(site_id)
    conditions.append(f"d.site_id = ${len(params)}")

if tag:
    # tag filter: tags JSONB must contain the value anywhere
    params.append(f'"{tag}"')
    conditions.append(f"d.tags::text ILIKE ${len(params)}")
    # OR for proper JSONB: params.append(tag); conditions.append(f"d.tags ? ${len(params)}")
    # Use JSONB ? operator if tags is JSONB and tag is a key,
    # or @> if filtering by key:value. Adjust to actual schema.

if search:
    params.append(search)
    conditions.append(
        f"(d.search_vector @@ plainto_tsquery('english', ${len(params)}) "
        f"OR d.device_id ILIKE '%' || ${len(params)} || '%')"
    )

where_clause = " AND ".join(conditions)

params.extend([limit, offset])
sql = f"""
    SELECT d.*
    FROM device_state d
    WHERE {where_clause}
    ORDER BY d.name ASC, d.device_id ASC
    LIMIT ${len(params) - 1}
    OFFSET ${len(params)}
"""
```

**Important**: Re-read the existing query structure before substituting.
The table may be `device_state` aliased as `d`, or it may join other tables.
Preserve all existing JOIN and column selections — only add WHERE conditions.

## Step 4: Add total count for pagination

Add a parallel count query:

```python
count_sql = f"SELECT COUNT(*) FROM device_state d WHERE {where_clause}"
total = await conn.fetchval(count_sql, *params[:-2])  # exclude limit/offset
```

Return in the response:

```python
return {
    "devices": rows,
    "total": total,
    "limit": limit,
    "offset": offset,
}
```

If the current response is just a list (not a dict), do not change the shape —
add the filters but keep the same response structure. Changing the response
shape would break the frontend.

## Step 5: Verify

```bash
# After service restart:
curl -s "http://localhost:8000/customer/devices?search=sensor&limit=5" \
  -H "Authorization: Bearer $TOKEN" | python3 -m json.tool | head -20

curl -s "http://localhost:8000/customer/devices?status=online&limit=10" \
  -H "Authorization: Bearer $TOKEN" | python3 -m json.tool | head -5
```
