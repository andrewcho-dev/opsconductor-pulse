# Task 002: Alert Rules CRUD API + Database Queries

> **CURSOR: EXECUTE THIS TASK**
>
> Read the instructions below and implement them exactly.
> Modify only the files listed in "Files to Modify".
> RUN THE TESTS in the Test section. Do not proceed if tests fail.
> IMPORTANT: Do not commit until all tests pass.

---

## Context

**THE PROBLEM**: Task 001 created the `alert_rules` table. Now we need CRUD endpoints so customers can create, view, edit, and delete alert rules via the API.

**Read first**:
- `services/ui_iot/db/queries.py` — focus on the integration_routes CRUD pattern (lines 258-383): `fetch_integration_routes`, `create_integration_route`, `update_integration_route`, `delete_integration_route`. These are the pattern to replicate.
- `services/ui_iot/routes/customer.py` — focus on:
  - Pydantic models (lines 160-182): `IntegrationCreate`, `IntegrationUpdate` pattern
  - Validation constants (lines 198-199): `ALERT_TYPES`, `SEVERITIES`
  - Integration route CRUD endpoints (lines 1830-1947): the pattern for list/get/create/update/delete
  - Helper functions (lines 200-221): `_validate_name`, `_normalize_list`

---

## Task

### 2.1 Add database query functions

**File**: `services/ui_iot/db/queries.py`

Add the following functions at the end of the file, following the exact same pattern as the integration_route functions:

**`fetch_alert_rules(conn, tenant_id, limit=100)`**:
```sql
SELECT tenant_id, rule_id, name, enabled, metric_name, operator, threshold,
       severity, description, site_ids, created_at, updated_at
FROM alert_rules
WHERE tenant_id = $1
ORDER BY created_at DESC
LIMIT $2
```
Return `[dict(r) for r in rows]`.

**`fetch_alert_rule(conn, tenant_id, rule_id)`**:
Same SELECT but with `WHERE tenant_id = $1 AND rule_id = $2`. Return `dict(row) if row else None`.

**`create_alert_rule(conn, tenant_id, name, metric_name, operator, threshold, severity=3, description=None, site_ids=None, enabled=True)`**:
- Generate `rule_id = str(uuid.uuid4())`
- INSERT with all fields, RETURNING all columns
- Return `dict(row)`

**`update_alert_rule(conn, tenant_id, rule_id, **kwargs)`**:
- Accept optional fields: `name`, `metric_name`, `operator`, `threshold`, `severity`, `description`, `site_ids`, `enabled`
- Use the dynamic SQL pattern from `update_integration_route` (lines 329-366): build `sets` list and `params` list with incrementing `$idx`
- Also set `updated_at = now()` in every update
- RETURNING all columns
- Return `dict(row) if row else None`

**`delete_alert_rule(conn, tenant_id, rule_id)`**:
```sql
DELETE FROM alert_rules WHERE tenant_id = $1 AND rule_id = $2
```
Return `result.split(" ")[-1] != "0"` (same pattern as `delete_integration_route`).

All functions must call `_require_tenant(tenant_id)` at the start.

### 2.2 Add Pydantic models

**File**: `services/ui_iot/routes/customer.py`

Add these models near the other Pydantic models (around line 182):

```python
VALID_OPERATORS = {"GT", "LT", "GTE", "LTE"}

class AlertRuleCreate(BaseModel):
    name: str = Field(..., min_length=1, max_length=100)
    metric_name: str = Field(..., min_length=1, max_length=100)
    operator: str = Field(...)
    threshold: float
    severity: int = Field(default=3, ge=1, le=5)
    description: str | None = None
    site_ids: list[str] | None = None
    enabled: bool = True

class AlertRuleUpdate(BaseModel):
    name: str | None = Field(default=None, min_length=1, max_length=100)
    metric_name: str | None = Field(default=None, min_length=1, max_length=100)
    operator: str | None = None
    threshold: float | None = None
    severity: int | None = Field(default=None, ge=1, le=5)
    description: str | None = None
    site_ids: list[str] | None = None
    enabled: bool | None = None
```

### 2.3 Update ALERT_TYPES constant

**File**: `services/ui_iot/routes/customer.py`

Find the `ALERT_TYPES` constant (line 198). Update it to include the types that ACTUALLY get generated:

```python
ALERT_TYPES = {"NO_HEARTBEAT", "THRESHOLD"}
```

Remove the aspirational types (`STALE_DEVICE`, `LOW_BATTERY`, etc.) that are never generated. Keep `NO_HEARTBEAT` (existing) and add `THRESHOLD` (new, generated by Phase 15 rule engine).

### 2.4 Add CRUD route handlers

**File**: `services/ui_iot/routes/customer.py`

Add these endpoint handlers. Follow the exact same pattern as the integration_routes endpoints (lines 1830-1947). Place them in a logical location — either near the alerts routes or at the end of the customer router.

**GET `/customer/alert-rules`** — List all rules for tenant:
- Auth: customer (read-only, same as integration-routes list)
- Get tenant_id from JWT
- Call `queries.fetch_alert_rules(conn, tenant_id)`
- If `?format=json` query param or Accept header is JSON: return JSON `{"tenant_id": ..., "rules": [...]}`
- Otherwise: return `templates.TemplateResponse("customer/alert_rules.html", {...})` (template created in Task 003)

**GET `/customer/alert-rules/{rule_id}`** — Get single rule:
- Auth: customer
- Validate rule_id format (should look like UUID)
- Call `queries.fetch_alert_rule(conn, tenant_id, rule_id)`
- Return 404 if not found
- Return JSON

**POST `/customer/alert-rules`** — Create rule:
- Auth: customer
- Parse body as `AlertRuleCreate`
- Validate `operator` is in `VALID_OPERATORS`, return 400 if not
- Validate `metric_name` matches pattern `^[a-zA-Z_][a-zA-Z0-9_]*$` (alphanumeric + underscore, starts with letter or underscore), return 400 if not
- If `site_ids` provided, validate each is non-empty string
- Call `queries.create_alert_rule(conn, tenant_id, ...)`
- Return 201 with created rule

**PATCH `/customer/alert-rules/{rule_id}`** — Update rule:
- Auth: customer
- Parse body as `AlertRuleUpdate`
- Validate any provided `operator` is in `VALID_OPERATORS`
- Validate any provided `metric_name` matches the pattern
- Call `queries.update_alert_rule(conn, tenant_id, rule_id, ...)`
- Return 404 if not found
- Return 200 with updated rule

**DELETE `/customer/alert-rules/{rule_id}`** — Delete rule:
- Auth: customer
- Call `queries.delete_alert_rule(conn, tenant_id, rule_id)`
- Return 204 on success, 404 if not found

### 2.5 Import the new query functions

**File**: `services/ui_iot/routes/customer.py`

Make sure the new query functions are accessible. If customer.py imports from `db.queries` (check the import at the top), the new functions should be available automatically. Verify the import pattern and ensure `fetch_alert_rules`, `fetch_alert_rule`, `create_alert_rule`, `update_alert_rule`, `delete_alert_rule` are importable.

---

## Files to Modify

| Action | Path | What changes |
|--------|------|--------------|
| MODIFY | `services/ui_iot/db/queries.py` | Add 5 alert_rules CRUD functions |
| MODIFY | `services/ui_iot/routes/customer.py` | Add Pydantic models, VALID_OPERATORS, CRUD endpoints, update ALERT_TYPES |

---

## Test

### Step 1: Run existing unit tests

```bash
cd /home/opsconductor/simcloud && python3 -m pytest tests/unit/ -v -x
```

All existing tests must pass. The ALERT_TYPES change may affect tests that validate against the old set — if any tests reference `STALE_DEVICE`, `LOW_BATTERY`, etc., update them to use the new values `NO_HEARTBEAT` and `THRESHOLD`.

### Step 2: Verify API endpoints

Read the code and confirm:
- [ ] All 5 query functions exist in queries.py with proper `_require_tenant` guards
- [ ] All 5 route handlers exist in customer.py
- [ ] `AlertRuleCreate` and `AlertRuleUpdate` Pydantic models defined
- [ ] `VALID_OPERATORS = {"GT", "LT", "GTE", "LTE"}` defined
- [ ] `ALERT_TYPES` updated to `{"NO_HEARTBEAT", "THRESHOLD"}`
- [ ] Operator validation rejects invalid values
- [ ] metric_name validation enforces alphanumeric + underscore pattern

---

## Acceptance Criteria

- [ ] 5 CRUD functions in queries.py: fetch_alert_rules, fetch_alert_rule, create_alert_rule, update_alert_rule, delete_alert_rule
- [ ] 5 REST endpoints: GET list, GET detail, POST create, PATCH update, DELETE
- [ ] Pydantic models validate input (name length, operator enum, severity range 1-5)
- [ ] metric_name validated to alphanumeric + underscore pattern
- [ ] ALERT_TYPES updated to actual generated types
- [ ] All existing unit tests pass

---

## Commit

```
Add alert rules CRUD API and database query functions

Customer endpoints for creating, viewing, editing, and deleting
threshold alert rules. Pydantic validation for operator, metric
name, and severity. Update ALERT_TYPES to actual generated types.

Phase 15 Task 2: Alert Rules CRUD API
```
